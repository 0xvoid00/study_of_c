# Pointer

## 메모리 감각 재활

### C 프로그램의 메모리 구조

> 코드가 실행될 때 RAM은 크게 4가지 영역으로 나뉨.  
> 이 때의 공간은 메모리 공간 전체가 아닌 OS가 부여한 일정 크기의 가상 메모리 공간임.

1. **Code** (Text) 영역: 작성한 코드가 기계어로 변환되어 저장
2. **Data** 영역: 전역 변수(Global), 정적 변수(Static)가 저장. (프로그램 시작부터 끝까지 생존)
3. **Heap** 영역: 프로그래머가 원할 때 만들고 지우는 공간 (`malloc`, `free`)
4. **Stack** 영역: 지역 변수, 매개 변수가 저장. 함수가 호출될 때 쌓이고, 끝나면 자동으로 사라짐  

```text
 Low Address (0x0000)
┌──────────────────┐ 
│      Code        │ (Text Segment)
├──────────────────┤
│      Data        │ (GVAR, BSS)
├──────────────────┤
│      Heap        │ (Grow up ↓)
├──────────────────┤
│        :         │
├──────────────────┤
│      Stack       │ (Grow down ↑)
└──────────────────┘ 
 High Address (0xFFFF)
```

> [!TIP]
> **BSS**는 프로그램 용량을 줄이기 위해 어짜피 0이 들어가는 놈들을 분리하여 나중에 넣겠다고 선언하는 용도이다

### 변수를 바라보는 시각 교정

Python에서 `a = 10`은 "a가 10을 가리킨다"에 가깝지만, C언어에서 `int a = 10;`은 매우 물리적

> "메모리 어딘가에 4바이트 공간을 잡고, 거기에 10이라는 값을 써라"

### Pointer 핵심

> Pointer의 본질은 결국 **주소를 담는 변수**

- `&`: 변수의 메모리 주소를 가져옴
- `*`: 주소를 찾아가서 그 안의 값을 건드림

``` c
#include <stdio.h>

void magic(int *p) {
    *p = *p + 10;
}

int main(void) {
    int a = 5;
    int *ptr = &a;

    printf("1. a의 값: %d\n", a);

    magic(ptr);

    printf("2. magic 호출 후 a의 값: %d\n", a);

    return 0;
}
```

> [!Important]
> **Call by Reference**라고 한다. 반대 개념으로는 Call by Value가 있다.

## Stride

### 배열은 사실 포인터다

> 컴파일러 입장에서 배열의 이름은 **첫 번째 원소의 주소값**으로 번역된다

``` c
int arr[3] = { 10, 20, 30 };
// arr == &arr[0]
```

> <!TIP>
> 여기서 배열의 이름은 배열의 시작 주소를 가리키는 포인터 상수(Constant Pointer, 다른 곳을 가리키도 변경 불가능)
